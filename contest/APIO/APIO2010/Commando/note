Copyright 2014 陈睿超<linuxer.sheep.0x@gmail.com>
本作品采用知识共享 署名-相同方式共享 4.0 国际 许可协议进行许可。访问 http://creativecommons.org/licenses/by-sa/4.0/deed.zh 查看该许可协议。

==================== 题意 ====================
给定长为n的序列x1, x2, x3, ..., xn。要求将序列划分为若干段（段数任意），使得权值和最大。
一段的权值为 ax^2 + bx + c ，其中x为该段各元素之和（即: 若x3, x4, x5为一段，则x = x3+x4+x5）。

所有输入数据均为整数
n ≤ 10^6
1 ≤ xi ≤ 100
-5 ≤ a ≤ -1
|b| ≤ 10^7
|c| ≤ 10^7

==================== 解 ====================
记序列x1, x2, x3, ..., xn的前缀和为S（为方便，下文混用S[i]和Si两种写法）

令F[i]表示将前i个元素划分为若干段所能获得的最大权值和
F[i] = max{ G[i,j] }    (j = 0 ~ i-1)
其中 G[i,j] = F[j] + a * (Si-Sj)^2 + b * (Si-Sj) + c

化简 G[i,j] 得 A(j) - B(i)*Sj + (a * Si^2 + b * Si + c)
其中 A(j) = F[j] + a*Sj^2 - b*Sj,  B(i) = 2a * Si

设j' ∈ argmax G[i,j]，则
G[i,j'] - G[i,j] ≥ 0
A(j') - A(j) - B(i) * (S[j'] - S[j]) ≥ 0
A(j') - A(j) ≥ B(i) * (S[j'] - S[j])
blahblahblah
总之A()是y坐标，S[]是x坐标，B()是直线斜率。S[]是单增的，B()是单减的，自左至右加点，维护一个上凸壳即可。

==================== 注意事项 ====================
n, |b|, |c|都给得很大，所以int32是存不下的。

TODO 为什么int64可过？不用高精吗？（叉乘那里可能会overflow吧？）
