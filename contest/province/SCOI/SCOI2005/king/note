Copyright 2014 陈睿超<linuxer.sheep.0x@gmail.com>
本作品采用知识共享 署名-相同方式共享 4.0 国际 许可协议进行许可。访问 http://creativecommons.org/licenses/by-sa/4.0/deed.zh 查看该许可协议。

TODO 这题能不能搜索？

==================== 逐行状压递推 ====================
需要记录当前行的状态和已经放的国王数量。空间复杂度O(K*2^N)。
转移的时候只需要枚举上一行的状态即可，到上一行为止已放的国王数量可以通过已放的国王数量减去当前行国王数量得到。
f[r][k][st] = Σ f[r-1][k-cnt(st)][st'] for all st' that doesn't conflict with st
判当前行与上一行是否冲突只要 st & st' = 0 and st>>1 & st' = 0 and st<<1 & st' = 0 即可
此外还要判当前行自身是否合法: st & st>>1 = 0
总复杂度O(N*K*4^N)，似乎不太行。

但是实际上我们不必枚举所有的st'。既然冲突的条件是(st|st<<1|st>>1) & st' ≠ 0，那么我们就只要枚举~(st|st<<1|st>>1)的子集就可以了（S'=(S-1)&U，不知道这个技巧的同学可以上网查一下）。
TODO 这样做的复杂度是多少？
btw, 可以使用滚动数组

TODO 如果用一个队列存下合法的状态，而不去管不合法状态的话，可能可以获得更低的复杂度。我们改成主动递推，从当前行推到下一行，把新的状态加进队列。以前好像有一题就是这么做的。

==================== 逐格状压递推 ====================
需要记录已经扫过的区域（或未扫过的区域）的“边缘”。例如，N=6，在做完第4行第4列，准备开始做第4行第5列的时候，可能是这样一种状态:
x x x x x x
x x x x x x
x x x 0 0 1
0 1 0 1 . .
. . . . . .
. . . . . .
x表示已经无关紧要的格子，.表示还没有做的格子，数字表示该格是否有国王。

如果我们把上面那幅图表示为0010101的话，就可以写出下面的递推式:
if invalid
            f[r][c][k][st] = 0
else if c==1
    if st&1 == 0
            f[r][1][k][st] = f[r-1][N][k][st>>1 | 1<<N]
                           + f[r-1][N][k][st>>1       ]
    else
            f[r][1][k][st] = f[r-1][N][k-1][st>>1 | 1<<N]
                           + f[r-1][N][k-1][st>>1       ]
else
    if st&1 == 0
            f[r][c][k][st] = f[r][c-1][k][st>>1 | 1<<N]
                           + f[r][c-1][k][st>>1       ]
    else
            f[r][c][k][st] = f[r][c-1][k-1][st>>1]

判是否合法:
    令a = st& ((1<<c)-1)，a&(a<<1) == 0
    令b = st&~((1<<c)-1)，b&(b<<1) == 0
    若c ≠ 1， st>>N 和 st&3 不能同时为非零数， 否则 st>>N 和 st&1 不能同时为1
    若c ≠ N， (st>>(N-1))&1 和 st&1 不能同时为1

时空复杂度均为O(N^2*K*2^N)，若原地操作的话（逐格递推连滚动数组都不用）空间复杂度可以降到O(N*K*2^N)

==================== 打表 ====================
1 <= N <= 9, 0 <= K <= N*N, 可能的输入有 Σ[i=1~9] i^2+1 = 9*(9+1)*(2*9+1) + 9 = 1719 种，完全可以事先打表。

==================== 注意事项 ====================
不难发现，密铺的话，最多可以放到平均4个格子一个国王，因此N=9的时候，最多可以放5*5=25个国王（别忘了N是一个奇数，而密铺铺法是隔一格放一个，所以9行中有5行可以放）。这样的话，答案的大小不会超过C^{25}_{81} = 81!/25!/56! = 5.26×10^20。已经超过了int64的存储范围。但是这只是比较粗略的估计。

从上面的分析中我们得到启发：我们可以把9*9的棋盘划分成25个2*2的块（边缘处则是 2*1, 1*2 或 1*1 ）。任何一种合法方案都不会在一个块中放置超过一个国王，因此方案的种数不超过 C^K_{5*5} * 4^K (K=0~25)
经过暴力手算，K=20时，该式取得最大值5.84*10^16。因此方案数不会超过int64
（用Ruby算出来的结果是log2(ans) <= 55.697239）
