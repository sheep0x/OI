Copyright 2014, 2015 陈睿超<linuxer.sheep.0x@gmail.com>
本作品采用知识共享 署名-相同方式共享 4.0 国际 许可协议进行许可。访问 http://creativecommons.org/licenses/by-sa/4.0/deed.zh 查看该许可协议。

==================== 我的想法 ====================
考虑一个数x与M!互质的条件。gcd(x,M!)的质因子必然是M!的质因子的子集，故 x与M!互质 等价于 x不包含M!的任何质因子，进而等价于 x不被1~M中的任何质数整除。

正难则反。互质的数的个数是不好算的，但是要把不互质的数剔掉看上去比较容易。
于是很容易想到用Möbius函数去容斥
ans = N! - 1~N!中2的倍数 - 1~N!中3的倍数 - ... + 1~N!中2*3的倍数 + ...
    = Σ[i=1~M]  μ(i) * ⌊ N!/i ⌋
由于N>=M，我们可以直接在求N!的时候少乘一个i，从而避免同余除法运算。

问题是，如果每次求N!的话，复杂度是O(NM)的。而且本题还有多组数据。所以必须事先求好N!，然后每次用O(1)的除法。所幸这题的模数是质数，我们可以事先预处理出乘法逆元。
现在的复杂度是O(MlogM + M + Q(N+M)) = O(MlogM + QN)

/*
我们可以分块求N!。预处理出O(√maxN)个N!，例如100!, 200!, 300!, ...。每次先查表得出一个阶乘，然后再在O(√N)的时间内暴力求得N!。
实际上因为我们要求很多次阶乘，所以不一定要按平方根来分块。若分K块的话，复杂度是O(MlogM + N + Q(N/K + M))
*/
啊...我傻了，直接预处理出所有的N!就可以了

现在的瓶颈是容斥，容斥需要O(QM)来求sum。如果Square-Free Number的个数是O(f(N))的话，我们就可以预处理出非零的μ()单独记下来。这样容斥的复杂度就可以降到O(Q*f(M))。问题是这个f(N)似乎不是很小。在前25个自然数中就有16个SFN了...这么看来的话，f(N)很可能是N之类的，那么复杂度就降不下来了


==================== 正解 ====================
先求出φ(M!)，即：1~M!中与M!互质的数的个数。根据剩余系的性质可知，(k-1)*M!+1 ~ k*M!中与M!互质的数的个数等于1~M!中与M!互质的数的个数。k可以取1 ~ N!/M!（因为N>M，所以M!|N!），所以ans = φ(M!) * N!/M!
φ(M!)用Euler's product formula来求。φ(M!) = Π[1<=i<=M] i is prime ? i-1 : i
N!事先暴力预处理出来。M!的欧拉函数和逆元也预处理出来，然后就可以O(1)回答询问了。
若使用线性求逆元，则总复杂度为O(N+M+Q)


==================== 附注 ====================
题目中没有保证R>=N。所以大部分流传的解法其实都不是严格正确的。但是大部分的测试数据和大部分的标程都是按照R>=N的假设来编写的。
但是实际上今天(2014-01-11)的测试数据的第10个点中第1个询问就出现了N>R的情况。除此之外，还有几个点也有N>R的情况。
实验表明，这种情况只要输出0就能通过，但是尚不清楚这是否是正确的答案（TODO）（实际上我认为这很有可能是错误答案），因为即使没有特别去考虑N>R的情况，大部分人的程序打出来的也是0。我们的程序也输出0，所以就过了。
今天的数据，第2个点和第4个点给出的R根本不是质数。使用扩欧求逆元的话，可能碰巧得到与标程相同的答案，从而AC。我修复了这两个数据，现在所有人都可以AC了（尽管仍然没有验证N>R的时候正确答案到底是不是0）。


==================== 加速的方法 ====================
我在预处理的时候只做了1~min(maxN, R)。wyf使用了一个更快的方法，就是先读入所有询问，然后做1~max(Ni)的预处理。由于本题的N大部分都远远小于R，这样做之后可以快很多（大部分人（包括我）都用了4s左右，采用了这个优化后，我和wyf都只用2s左右）。
本题的空间限得很紧，我为了省空间不得不共享了一个数组。wyf使用了一个有效的时间换空间，将存储f[m] = φ(m!)/m!的那个数组的大小从10^7降到了降到了不到7*10^5。我们注意到，
        if i is prime
            f[i] = f[i-1] * (i-1) * inv[i]
        else
            f[i] = f[i-1] * i * inv[i] = f[i-1]
。而合数是相当多的，因此我们可以只存下f'[k] = f[k-th prime]。然后在询问的时候O(logN)二分查找k。总时间复杂度是O(N+M+QlogN)。但是因为Q非常小（10^4），所以速度跟时间换空间之前几乎一样快，而省下了将近一半的空间。

经过我的仔细修改，内存开销只有125512K。可是wyf只用了119764K。我反复对照，没有发现哪里多用了内存，照理说应该是我比他用的内存少才对。后来终于发现问题在于GCC，改成G++编译之后我只用了96160K。这区别也太大了吧...（如果是其他编译器我还能理解，为什么推崇C的GNU出的编译器竟然会把几乎一模一样的程序编译得差这么多，照理说应该是C的编译结果更优才对）
（以上评测结果来自机房的Cena）
