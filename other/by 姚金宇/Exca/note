Copyright 2014 陈睿超<linuxer.sheep.0x@gmail.com>
本作品采用知识共享 署名-相同方式共享 4.0 国际 许可协议进行许可。访问 http://creativecommons.org/licenses/by-sa/4.0/deed.zh 查看该许可协议。

==================== 来源 ====================
题目描述和原作者可在Amber涛的国家集训队论文《最小割模型在信息学竞赛中的应用》的第5.4.2小节找到。

==================== 解 ====================
Amber涛的论文当中给出了详细解答。
以下是个人的解答，兼当草稿和笔记。

---------- 回合 ----------
“每回合按顺序做若干件事情”的这种题目很头疼...总是没思路...
只有偶数秒宝石才会消失？这是个明显的线索。

我们两秒两秒地考虑:
第0秒:  取走一个宝石（宝石价值为负数什么的咱就不考虑了吧= =）
        清空以自身为中心的小十字（清空4格跟清空5格差别不大，为了便于思考，就当作清空5格吧）
        移动至多1步
第1秒:  # 此时必然身处空地，故没有宝石可取
        # 奇数秒宝石不会消失
        移动至多1步
显然上面的讨论对于任意的第2k~(2k+1)秒都是成立的（但是第一步不一定有宝石可取）。

为方便，我们将这样的两秒称为一个回合。
一个回合中，其实只做了三件事:
    1. 取走宝石（若有宝石可取）
    2. 清空十字
    3. 移动0~2步
易证，移动0步是没有意义的。假设我们连续k个回合都原地不动(k>0)，然后第k+1个回合移动了至少1步，会发生什么呢？第一个回合可以取走宝石和清空十字。第2~(k+1)个回合都没有宝石可取，而十字已经清空了，所以反复清空等效于什么也没发生。最后，第k+1个回合可以移动1~2步。根据上述分析可以发现，做这k+1个回合，等效于跳过前k个回合，直接做第k+1个回合。

---------- 错误的想法: 黑白格棋盘 ----------
一开始我掉进一个误区，觉得移动1步的话拿不到宝石，反而会白白清掉一些尚未取得的宝石，很吃亏。于是贪心地认为总是应该走2步。然后很容易就可以证明只有两种取法可能是最优的: 想像这是一张国际象棋棋盘，取走所有白格或者取走所有黑格。这样的话，不是直接扫一遍取个max就可以求出答案了吗？我在这个错误的想法上耗费了不少时间（总觉得有什么不对劲= =）。
估计作者都没有想到我会这么傻吧...

为什么移动1步可能比移动2步优呢？从上面的错误想法中不难看出原因: 贪心地每次走2步的话，只能取到同种颜色的格子。考虑下面的例子:
    1 50  1
    1  1  1
    1  1 50
取黑/白格的话，最多取到总价值为54的宝石。然而很容易就可以发现，最优解法必然可以取到总价值至少100的宝石。
比方说:
    1 50  1     tick:   0
    1  1  1     step:   1
    1  1  @     value: 50

    1 50  1     tick:   0
    1  1  _     step:   2
    1  _  @     value: 50

    1 50  1     tick:   0
    1  1  @     step:   3
    1  _  _     value: 50

    1 50  1     (tick, step):   (1,1), (1,2), (1,3), (2,1)
    1  1  @
    1  _  _     value: 50

    1 50  _     tick:   2
    1  _  @     step:   2
    1  _  _     value: 50

    1 50  @     tick:   2
    1  _  _     step:   3
    1  _  _     value: 50

    1 50  @     tick:   3
    1  _  _     step:   0~1
    1  _  _     value: 50

    1 50@ _     tick:   3
    1  _  _     step:   2
    1  _  _     value: 50

    1  @  _     tick:   4
    1  _  _     step:   0
    1  _  _     value:100

    ...

从上面的例子我们可以发现，如果我们要突破 只能取白格/只能取黑格 的限制的话，就要牺牲一些宝石，但是这个tradeoff可能是值得的。

折腾了半天，又回到原点了。嘛，不过至少得到了一些简单的结论和感性的理解。

---------- 构造 ----------
我们换个思路，不要考虑“怎么走最优”，而是先决定“取哪些格子”，然后再尝试构造一种走法，使得这些格子被取到（如果可以的话，最好还保证其他格子不被取到）。

说到黑白格，通常会想到二分图（为了这么简单的结论我竟然绕了一大圈...条件反射什么的太迟钝了啊）
虽然“不同颜色的格子可以同时取”，但是只要“不能同时取的格子颜色不同”，就可以构造二分图了。
这个条件，满足吗？
嗯...不知道

显然相邻格子不能同时取。不妨大胆猜想: 只有相邻格子不能同时取；只要满足这个条件，就可以任取。
我们不直接证明这个猜测，而是先看看能不能构造出走法。反正我们迟早是要构造一种走法的，只要构造出走法，不就自然而然地证明了吗？

有一个简单但重要的性质: （在任何一个回合结束之后，下一个回合开始之前，）空地总是连续的。或者说，空地总是形成连通块 （证明就略了）
注: 最外圈的空地是“危险区”，如果在偶数秒踩在危险区上的话，就可能导致某些宝石消失。除去危险区，剩下的空地都是“安全区”，可以自由走动，而不会造成任何影响。
根据这个性质，可以轻松构造出一个策略:

考虑紧挨着空地边缘的一圈格子（不妨称为扩展区）。为便于理解，附图:
    1 1 1 1 1 1
    1 1 1 # 1 1
    1 1 # _ # 1         _   空地（为了整洁，危险区和安全区均标为“_”）
    1 # _ _ _ #         #   扩展区
    # _ _ _ # 1         1   其余宝石
    1 # _ # 1 1
    1 1 # 1 1 1

如果这一圈格子中有我们要取的格子，我们就取走它。具体地，我们先走到最接近这个格子的安全区格子（之一），然后等待下一个偶数秒。在偶数秒，我们从安全区移动到要取的格子旁边的危险区，然后下一秒，我们移动要要取的格子之上；这个过程中没有任何宝石受到影响。再下一秒，我们取走宝石，并清空以自身为中心的十字中的宝石。因为相邻的格子本来就不能同时取到，所以这一步清空的宝石中一定没有我们计划取得的宝石，所以是安全的。
如果扩展区中不存在我们要取的格子，我们就可以放心地走进危险区，清除扩展区中的宝石，扩大空地的范围，直到某个我们要取的格子出现在扩展区中。

最开始的时候，任选一个要取的格子作为起点。反复进行上面的操作，直到整幅图变成空地为止。此时必然取到了所有计划要取的宝石（实际上我们还可以保证所有计划外的宝石都不会被取到，这个证明就略了）。

至此，我们构造出了一个策略，对于任意一个“不会同时取到相邻两个格子”的取法，都能够给出一种合法的走法。

---------- 取格子 ----------
现在我们只要能够求出“不会同时取到相邻两个格子”的最优的取法，这道题就算解决了。

简要描述一下构图: 黑格子放左边，白格子放右边，相邻格子之间连边。连边的格子不能同时取。要取出一些点使得权值和尽可能大。
显然，这是二分图最大点权独立集。照搬算法就可以了。
